// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1388.frc2019official.subsystems;


import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

//TODO: import org.usfirst.frc1388.frc2019official.UsbLogging;

import org.usfirst.frc1388.frc2019official.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class Elevator extends Subsystem {        
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final DigitalInput bottomElevatorSwitch; //TODO
    private final Encoder elevatorEncoder; //TODO
    private final WPI_VictorSPX elevatorMotor; //TODO
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public enum ElevatorSetpoint{
        //TODO: Set points to actual values
        /*LOWESTHATCHROCKET(0),
        LOWESTBALLROCKET(0),
        CARGOHATCH(0),
        CARGOBALL(0),
        MIDHATCHROCKET(0),
        MIDBALLROCKET(0),
        INITALPOSITION(0); // maybe?
        */
        SCALE(77), //TODO implement above
		SWITCH(30),
		DEPLOYARMS(20),
		BOTTOM(0),
		DONTKNOW(0);

        private double distance;

        private ElevatorSetpoint(double distance){
            this.distance = distance;
        }

        public double getDistance(){
            return this.distance;
        }
    }
    // The below refer to the height in inches of various critical points of the elevator
    public final double k_maxHeight = 81; // max height limit TODO: fill in max height
    public final double k_lowestHeight = 0; // lowest height limit TODO: fill in min height
    public final double k_maxHeightMargin = 3; // margin of error for the elevator's max height TODO: fill in margin

    // The below refer to various critical limits of the motors in inches
    private final double k_maxPwrUp = 1.0; //max power when moving up TODO: fill in and Test
	private final double k_finalPwrUp = 0.5; //max power when elevator is at top TODO: fill in and Test
	private final double k_rampDistUp = 2; //distance from top when power will scale down TODO: fill in and Test

	private final double k_maxPwrDwn = -1.0; //max power when moving down TODO: fill in and Test
	private final double k_finalPwrDwn = -0.4; //max power when elevator is at bottom TODO: fill in and Test
	private final double k_rampDistDwn = 30; //distance from bottom when power will scale down TODO: fill in and Test
	
	private final double k_slopeUp = (k_maxPwrUp - k_finalPwrUp) / k_rampDistUp; // slope of the limit = y / x = power / distance
	private final double k_slopeDwn = (k_maxPwrDwn - k_finalPwrDwn) / k_rampDistDwn; // slope of the limit = y / x = power / distance

	private boolean m_initialized = false; 
	private boolean m_prevAtBottomLimit = false;
    public Elevator() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS        
        elevatorEncoder = new Encoder(5, 4, false, EncodingType.k4X); //TODO
        elevatorEncoder.setDistancePerPulse(0.0169270833);//TODO
        elevatorEncoder.setPIDSourceType(PIDSourceType.kDisplacement); //TODO
        bottomElevatorSwitch = new DigitalInput(8);
        elevatorMotor = new WPI_VictorSPX(12);
        elevatorMotor.setNeutralMode(NeutralMode.Brake);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ElevatorMove());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        double currentPwr = elevatorMotor.get();
        double limitedPwr = limitMotorPwr(currentPwr, false);

        if (Math.abs(currentPwr - limitedPwr) > 0.1) {
			//TODO: UsbLogging.printLog("Warning: Elevator motor power limit exceeded!");
        }
        // Zero the encoder if the elevator is at the bottom limit switch and set the elevator initialized flag
		if (atBottomLimit()) {
			if (! m_prevAtBottomLimit) {
				//TODO: UsbLogging.printLog("Elevator encoder held in reset; pre-reset value: " + elevatorEncoder.getDistance());
			}
			
			// set the elevator encoder to zero so that we can use it to measure elevator height for set points 
			// and so that we can ensure that the elevator height does not exceed the limits. 
			elevatorEncoder.reset();
			m_initialized = true;
        }
        else {
			if (m_prevAtBottomLimit) {
				//TODO: UsbLogging.printLog("Elevator encoder released from reset");
			}
		}
		m_prevAtBottomLimit = atBottomLimit();
    }

    public boolean atBottomLimit() {
		// Elevator switch returns true when switch is not pressed because normally open, invert
		// to represent whether or not switch is pressed
		return !bottomElevatorSwitch.get();
    }

    public boolean atTopLimit() {
		boolean atLimit = true;     // default is the safest value

		double height = getHeight(); // will return negative if height not found or encoder not zeroed

		if ((height < k_maxHeight) && (height >= 0)) {
			atLimit = false;
		}
		
		return atLimit;

    }
    // height will return negative in case of error
    public double getHeight() {
        double height = -1;
		// height is encoder distance + distance of bottom of elevator to floor
        height = elevatorEncoder.getDistance() + k_lowestHeight;
        //			double lidarHeight = (elevatorLidar.getDistance() * k_inPerCm) + k_lidarOffset;
                    
        final double acceptableErrorMargin = 1.0;
                    
        //			if(Math.abs(lidarHeight - height) > acceptableErrorMargin)
        //				System.out.println("LIDAR and Encoder not in agreement within specified margin of error");
        
                    // maxHeight plus offset = height relative to floor
        if (height < 0 || height > (k_maxHeight + k_maxHeightMargin)) {
            // something is wrong
            height = -1;
        }
        
        if (m_initialized == false) {
            height = -1;
            // print out if encoder not initialized
        }
        return height;
    }

    public double distanceAboveSetPoint(ElevatorSetpoint setpoint) {
		return distanceAboveSetPoint(setpoint.getDistance());
    }
    
	public double distanceAboveSetPoint(double setpoint) {
		double delta;
		delta = getHeight() - setpoint;

		return delta;
    }
    
    public double setMotor(double pwr, boolean override) {
		double limitedPwr = limitMotorPwr(pwr, override);

		elevatorMotor.set(limitedPwr);

		return limitedPwr;
	}

    public double limitMotorPwr(double pwr, boolean override) {
		double pwrRequested = pwr; 

		double height = getHeight();

		// max power limit
		if (pwr > k_maxPwrUp) pwr = k_maxPwrUp;                         // Never exceed the max Up power
		if (pwr < k_maxPwrDwn) pwr = k_maxPwrDwn;                       // Never exceed the max Down power

		if(override == false ) {

			// top/bottom limits (limit switches or soft limits)
			if (atTopLimit()    && (pwr > 0)) pwr = 0;                          // Do not go up
			if (atBottomLimit() && (pwr < 0)) pwr = 0;                          // Do not go down

			// Reduce the power as the elevator approaches top/bottom limits
			if (isHeightValid()) {
				// Height of the elevator is known; apply ramped limits based on height
				double upLimit, dnLimit, distance;

				// limit the power when approaching the top limit
				distance = k_maxHeight - height;                               // distance from the limit
				upLimit = k_finalPwrUp + (distance * k_slopeUp);				   // calculating upLimit, could much greater than maxPwrUp
				pwr = Math.min(pwr, upLimit);								   // use appropriate value within range
				
				// limit the power when approaching the bottom limit
				distance = height - k_lowestHeight;                            // distance from the limit
				dnLimit = k_finalPwrDwn + (distance * k_slopeDwn);				   // calculating dnLimit, could much less than maxPwrDwn
				pwr = Math.max(pwr, dnLimit);								   // use appropriate value within range
			}
			else {
				// height is unknown; apply "final" limits
				if (pwr > k_finalPwrUp) pwr = k_finalPwrUp;
				if (pwr < k_finalPwrDwn) pwr = k_finalPwrDwn;
			}

		}

		return pwr;

    }
    
    public boolean isHeightValid() {
		return (getHeight() > 0);
	}

    public boolean isinitialized() {
		return m_initialized;
	}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

