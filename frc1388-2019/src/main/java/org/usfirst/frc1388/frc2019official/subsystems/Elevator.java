// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1388.frc2019official.subsystems;


import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

import org.usfirst.frc1388.frc2019official.RobotMap;
import org.usfirst.frc1388.frc2019official.UsbLogging;

import org.usfirst.frc1388.frc2019official.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class Elevator extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private DigitalInput bottomElevatorSwitch1;
    private DigitalInput bottomElevatorSwitch2;
    private Encoder elevatorEncoder;
    private WPI_VictorSPX elevatorMotor;
    private DoubleSolenoid leanControl;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public enum ElevatorSetpoint{
        //TODO: Set points to actual values
        /*LOWESTHATCHROCKET(0),
        LOWESTBALLROCKET(0),
        CARGOHATCH(0),
        CARGOBALL(0),
        MIDHATCHROCKET(0),
        MIDBALLROCKET(0),
        INITALPOSITION(0); // maybe?
        */
        SCALE(77), //TODO implement above
		SWITCH(30),
		DEPLOYARMS(20),
		BOTTOM(0),
		DONTKNOW(0);

        private double distance;

        private ElevatorSetpoint(double distance){
            this.distance = distance;
        }

        public double getDistance(){
            return this.distance;
        }
    }

    // The below refer to the height in inches of various critical points of the elevator
    public final double k_maxHeight = 40; // max height limit TODO: fill in max height
    public final double k_lowestHeight = 0; // lowest height limit TODO: fill in min height
    public final double k_maxHeightMargin = 3; // margin of error for the elevator's max height TODO: fill in margin

    // The below refer to various critical limits of the motors in inches
    private final double k_maxPwrUp = 0.5; //max power when moving up TODO: fill in and Test
	private final double k_finalPwrUp = 0.3; //max power when elevator is at top TODO: fill in and Test
	private final double k_rampDistUp = 5; //distance from top when power will scale down TODO: fill in and Test

	private final double k_maxPwrDwn = -0.5; //max power when moving down TODO: fill in and Test
	private final double k_finalPwrDwn = -0.3; //max power when elevator is at bottom TODO: fill in and Test
	private final double k_rampDistDwn = 15; //distance from bottom when power will scale down TODO: fill in and Test
	
	private final double k_slopeUp = (k_maxPwrUp - k_finalPwrUp) / k_rampDistUp; // slope of the limit = y / x = power / distance
	private final double k_slopeDwn = (k_maxPwrDwn - k_finalPwrDwn) / k_rampDistDwn; // slope of the limit = y / x = power / distance

    private final double k_initialHeight = 25;  // designated elevator starting height (approximate) TODO: fill in and Test

    private final double k_minLeanHeight = 25;  // do not lean the tower if the elevator is below this TODO: fill in and Test

    private boolean m_initialized = false; 
    private boolean m_prevAtBottomLimit = false;
    private boolean m_towerUpright = false;
    

    public Elevator() {
        elevatorEncoder = new Encoder(RobotMap.DIO_elevatorEncoderA, RobotMap.DIO_elevatorEncoderB,
            false, EncodingType.k4X); //TODO
        elevatorEncoder.setDistancePerPulse(0.0169270833);//TODO

        bottomElevatorSwitch1 = new DigitalInput(RobotMap.DIO_bottomLimit1);
        bottomElevatorSwitch2 = new DigitalInput(RobotMap.DIO_bottomLimit2);

        elevatorMotor = new WPI_VictorSPX(RobotMap.CANID_elevatorMotor);
        elevatorMotor.setNeutralMode(NeutralMode.Brake);

        leanControl = new DoubleSolenoid(RobotMap.CANID_PCM2, RobotMap.PCMCH_towerPush, RobotMap.PCMCH_towerPull);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        setDefaultCommand(new ElevatorMove());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

        // ensure the elevator motor is always set to the limit in case some code 
		// or external influence did not call setMotor() which limits the power
        double currentPwr = elevatorMotor.get();
        double limitedPwr = limitMotorPwr(currentPwr);

        if (Math.abs(currentPwr - limitedPwr) > 0.1) {
			UsbLogging.info("Warning: Elevator motor power limit exceeded!");
        }
        // Zero the encoder if the elevator is at the bottom limit switch and set the elevator initialized flag
		if (atBottomLimit()) {
			if (! m_prevAtBottomLimit) {
				UsbLogging.info("Elevator encoder held in reset; pre-reset value: " + elevatorEncoder.getDistance());
			}
			
			// set the elevator encoder to zero so that we can use it to measure elevator height for set points 
			// and so that we can ensure that the elevator height does not exceed the limits. 
			elevatorEncoder.reset();
			m_initialized = true;
        }
        else {
			if (m_prevAtBottomLimit) {
                UsbLogging.info("Elevator encoder released from reset");
			}
		}
		m_prevAtBottomLimit = atBottomLimit();
    }

    /**
	 * Determine if the elevator is at the bottom limit
	 * <p>
	 * The lower limit is a hard limit, implemented as a pair of limit switches.
	 *  
	 * @return    Elevator is at the lower limit
	 */
    public boolean atBottomLimit() {
        // TODO: verify polarity
		return bottomElevatorSwitch1.get() || bottomElevatorSwitch2.get();
    }

	/**
	 * Determine if the elevator is at the top limit
	 * <p>
	 * The top limit is a soft limit, determined by elevator height.
	 *  
	 * @return    Elevator is at the upper limit
	 */
    public boolean atTopLimit() {
		boolean atLimit = true;     // default is the safest value

		double height = getHeight(); // will return negative if height not found or encoder not zeroed

		if ((height < k_maxHeight) && (height >= 0)) {
			atLimit = false;
		}
		
		return atLimit;

    }
    
	/**
	 * Return the elevator height
	 * <p>
	 * If the height cannot be determined, a negative value will be returned
	 *  
	 * @return    Height in inches relative to ground, or negative if height cannot be determined
	 */
    public double getHeight() {
        double height = -1;
		// height is encoder distance + distance of bottom of elevator to floor
        height = elevatorEncoder.getDistance() + k_lowestHeight;

        if (!isinitialized()) {
            // account for approximate starting position
            height += k_initialHeight;
        }
                    
        // maxHeight plus offset = height relative to floor
        if (height < 0 || height > (k_maxHeight + k_maxHeightMargin)) {
            // something is wrong
            height = -1;
        }
        
        if (m_initialized == false) {
            height = -1;
            // print out if encoder not initialized
        }
        return height;
    }

    public double distanceAboveSetPoint(ElevatorSetpoint setpoint) {
		return distanceAboveSetPoint(setpoint.getDistance());
    }
    
	public double distanceAboveSetPoint(double setpoint) {
		double delta;
		delta = getHeight() - setpoint;

		return delta;
    }
    
	/**
	 * Set the elevator motor power, after enforcing power limits
	 * <p>
	 * To ensure that the elevator is not overdriven, this method should be used to set the motor power,
	 * and the motor's power should NOT be set directly using the motor's set() method.
	 *  
	 * @param     pwr   Desired motor power
	 * @return          Actual motor power that was set
	 */
    public double setMotor(double pwr, boolean override) {
        if (! override) {
            pwr = limitMotorPwr(pwr);
        }

		elevatorMotor.set(pwr);

		return pwr;
	}

	/**
	 * Check elevator motor power limits
	 * <p>
	 * Desired motor power is to be limited based on max allowable power, physical limits, and proximity to physical limits.
	 * Convert desired power value to limited power value based on constraints
	 *  
	 * @param   pwr         Desired motor power value
	 * @return              Limited motor power value
	 */
    private double limitMotorPwr(double pwr) {

		double height = getHeight();

		// max power limit
		if (pwr > k_maxPwrUp) pwr = k_maxPwrUp;                         // Never exceed the max Up power
		if (pwr < k_maxPwrDwn) pwr = k_maxPwrDwn;                       // Never exceed the max Down power

        // top/bottom limits (limit switches or soft limits)
        if (atTopLimit()) {
            pwr = Math.max(pwr, 0);                         // Do not go up
        }
        if (atBottomLimit()) {
            pwr = Math.min(pwr, 0);                         // Do not go down
        }
        if (! m_towerUpright && (getHeight() <= k_minLeanHeight)) {
            pwr = Math.min(pwr, 0);                         // Do not go down
        }

        // Reduce the power as the elevator approaches top/bottom limits
        if (isHeightValid()) {
            // Height of the elevator is known; apply ramped limits based on height
            double upLimit, dnLimit, distance;

            // limit the power when approaching the top limit
            distance = k_maxHeight - height;                               // distance from the limit
            upLimit = k_finalPwrUp + (distance * k_slopeUp);				   // calculating upLimit, could much greater than maxPwrUp
            pwr = Math.min(pwr, upLimit);								   // use appropriate value within range
            
            // limit the power when approaching the bottom limit
            distance = height - k_lowestHeight;                            // distance from the limit
            dnLimit = k_finalPwrDwn + (distance * k_slopeDwn);				   // calculating dnLimit, could much less than maxPwrDwn
            pwr = Math.max(pwr, dnLimit);								   // use appropriate value within range
        }
        else {
            // height is unknown; apply "final" limits
            if (pwr > k_finalPwrUp) pwr = k_finalPwrUp;
            if (pwr < k_finalPwrDwn) pwr = k_finalPwrDwn;
		}

		return pwr;

    }
    
    public boolean isHeightValid() {
		return (getHeight() > 0);
	}

    public boolean isinitialized() {
		return m_initialized;
	}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    /**
     * Stand the tower upright
     */
    public void stand(){
        leanControl.set( DoubleSolenoid.Value.kForward ); // pushes the actuator forward
        m_towerUpright = true;
    }

    /**
     * Lean the tower back
     */
    public void lean(){
        // check that the elevator is high enough before leaning
        if (getHeight() >= k_minLeanHeight) {
            leanControl.set( DoubleSolenoid.Value.kReverse ); // retracts the actuator 
        }
        m_towerUpright = false;
    }

    public void deactivate(){
        leanControl.set( DoubleSolenoid.Value.kOff ); // stops powering the solenoid
    }
}
